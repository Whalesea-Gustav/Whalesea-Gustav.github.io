---
title: 正则表达式RegExp
date: 2018-09-21 01:10:00
tags: [JavaScript, Font-end]
categories: 网络编程
---

---
## 正则表达式知识

### 正则表达式基础
直接给出字符可以精确匹配
通用匹配
1. `\d` 匹配一个数字
2. `\w` 匹配一个字母
3. `.` 匹配任意字符
4. `\s` 匹配空格，`\t`

多字符匹配
1. `*` 表示前面的规则应用任意个字符
2. `+` 表示匹配至少一个字符
3. `?` 表示匹配0~1个字符
4. `{n}` 表示精确指定n个字符串
5. `{n,m}` 表示匹配n~m个字符

### 正则表达式进阶
[范围规则ruler]表示一个字符在范围内匹配
1.  [0-9]                   匹配一个数字
2.  [0-9A-Za-z]        匹配一个数字或者字母
3.  [0-9A-Za-z\_]     匹配一个数字或者字母或者下划线
4.  [0-9A-Za-z\_] +  匹配至少一个(数字或者字母或者下划线) 例如 `'a110'`, `'0_Z'`, `'js2015'`
5. 多个[ ]组合 [a-zA-Z\_\$][0-9a-zA-Z]{0, 19} 精确指定长度为1-20个字符 (前面一个字符开头，后面0~19个指定字符)

`A|B` 表示匹配A或者B `(J|j)ava(S|s)cript`可以匹配'JavaScript', 'javascript'等
`^` 表示后面的规则应用于第一个字符        `^\d`表示以一个数字开头
'$'  表示前面的规则应用于最后一个字符    '\d$` 表示一一个数字结尾

需要转义的字符
1. 保留字符
    +  `+` --- `\+`
    + `*` --- `\*`
    + `?` --- `\?`  
    + `$` --- `\$`
    + `.` --- `\.`
    + `[` `]` --- `\[` `\]`
    + `{` `}` --- `\{` `\}`
    + `(` `)` --- `\(` `\)`
    + `|` --- `\|`
    + `/` --- `\/`
2. 制表，换行，空(null)，垂直制表，换页，空格  --- `\t`  `\n`  `\0` `\v`  `\f` `\s`

---
## JavaScript中的RegExp
javascript中有两种创建正则表达式的方式
1. `/正则表达式/` 赋值给变量
2. `new RegExp('正则表达式')` 创建一个`RegExp`对象

```javascript
var re1 = /ABC\-001/;                   //方法1
var re2 = new RegExp('ABC\\-001');      //方法2
re1;     // /ABC\-001/
re2;     // /ABC\-001/
```

第二种方法时，字符中需要转义，`\\`表示转义出一个`\`

### 判断正则表达式是否匹配

`RegExp.test(testString)`
使用`test`方法来测定给定的字符串是否符合条件

```javascript
var re = /^d{3}\-\d(3,8}$/;
re.test('010-12345');     // true
re.test('010-1234x');     // false
```
### 切分字符串
`string.split(/正则表达式/);` 
`string`中去除符合正则表达式的子字符(串)，然后剩下的子字符串组形成一个`Array`

```javascript
'a b;;  ,,,  c'.split(/[\s\;\,]+/);   //['a', 'b', 'c']
```
### 分组
类似于python re.math中分组后的group
正则表达式中，用`()`包括起来的就是需要提取的分组(group)
`RegExp.exec(String)`就可以将**符合正则表达式的字符串**，按组提取出子字符串，将其组合成一个`Array`

```javascript
var re = /^(\d{3}-(\d{3,8}$/;
re.exec('010-12345');        // ['010-12345', '010', '12345']
re.exec('010 12345');        // null
```

---
## 贪婪匹配
正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符
```javascript;
var re = /^(\d+)(0*)$/;
re.exec('102300');        // ['102300', '102300', '']
```
`\d+`把所有`0`都匹配了

### 进入非贪婪模式
默认是贪婪模式；在**量词**后面直接加上一个`？`就是非贪婪模式
```javascript
var re = /^(\d+?)(0*)$/;
re.exec('102300');          //['102300', '102, '00']
```

---
## 全局搜索
JavaScript有特殊标志 - 其中较为特殊的是`g`，表示全局匹配
```javascript
var r1 = /test/g;
//等价于
var r1 = new RegExp('test', 'g');
```
全局可以多次执行`exex()`方法，去搜索字符串中符合的子字符串
当使用全局搜索时，每次运行`exec()`， 正则表达式会更新`lastIndex`属性，其表示上次匹配的最后的索引
```javascript
var s = 'JavaScript, VBSript, ECMAScript';
var pattern1 = /[a-zA-Z]+Script/g;
// 使用全局匹配:
re.exec(s);      // ['JavaScript']
re.lastIndex;    // 10

re.exec(s);      // ['VBScript']
re.lastIndex;    // 20

re.exec(s);      // ['JScript']
re.lastIndex;    // 29

re.exec(s);      // ['ECMAScript']
re.lastIndex;    // 44

re.exec(s);      // null，直到结束仍没有匹配到
```
全局匹配类似搜索，因此不能使用`/^...$/`，那样只会最多匹配一次

