---
title: 方法
date: 2018-09-20 23:58:39
tags: [JavaScript, Font-end]
categories: 网络编程
---

---
## 方法 - 对象中绑定函数

在一个对象中绑定函数，则称之为方法

```
var xiaoming = {
    name : '小明‘，
    birth : 1990
    age: function() {
            var y = new Data().getFullYear();
            return y - this.birth;
    }
};
xiaoming.age; // fuction xiaoing.age
xiaoming.age(); //2018 - 1990
```



------

## this 关键字

绑定到对象的函数成为方法，但在内部使用了一个this关键字，对就是那个this/self
`this`是一个特殊变量，它始终指向当前对象。访问同一对象的其他属性时，需要用到`this`变量。



### this关键字的坑

this的指向很迷
JavaScript函数内部调用的`this`，其所指的对象视情况而定

1. 如果被对象的方式调用，则只想被调用的对象 
2. **如果单独调用，则`this`指向全局对象，也就是`windows`**

```javascript
function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}

var xiaoming = {
    name: '小明',
    birth: 1990,
    age: getAge
};

xiaoming.age() // 2018 - 1990
getAge(); // NaN
```

甚至以下情况也会错误

```javascript
    var fn = xiaoming.age;
    fn(); //NaN
```



#### `obj.xxx`来调用正确的`this`
要保证`this`指向正确，一定要用`obj.xxx`来调用正确的`this`

ECMA决定，在strict模式下，让函数模式下的`this`指向`undefined`，因此，在strict的模式下，会``raise Error`

```javascript
'use strict';

var xiaoming = {
    name: '小明',
    birth: 1990,
    age: function () {
        var y = new Date().getFullYear();
        return y - this.birth;
    }
};
var fn = xiaoming.age;
fn(); // Uncaught TypeError: Cannot read property 'birth' of undefined
```

#### 方法的this/方法内部函数的this

方法内部函数中的`this`又指向`udnefined` / 在非`strict`模式下，指向`window`

```javascript
'use strict';

var xiaoming = {
    name: '小明',
    birth: 1990,
    age: function () {
        function getAgeFromBirth() {
            var y = new Date().getFullYear();
            return y - this.birth;
        }
        return getAgeFromBirth();
    }
};

xiaoming.age(); // Uncaught TypeError: Cannot read property 'birth' of undefined
```



#### 解决方法

用`that`变量捕获`this`

```javascript
'use strict'

var xiaoing = {
    name: '小明',
    birth: 1990,
    age: fuction () {
    var that = this;
    fucntion getAgeFromBirth() {
        var y = new Data().getFullYear();
        return y - that.birth;
    }
};
xiaoing.age; // 2018 - 1990
```

在`var that = this;`（方法内部使用this赋值给that）后，在方法内部函数中，可以放心地调用that。





------

## apply

函数本身具有`apply`方法，接受两个参数 - 1，需要绑定`this`的变量。2，`Array`，表示本来要传传递给函数的参数

```javascript
fucntion getAge() {
    var y = new Data().getFullYear();
    return y - this.birth;
}
var xiaoming = {
    name: '小明',
    birth: 1990,
    age: getAge
};
xioaming.age(); //25
getAge.apple(xiaoming,[]); //传递空Array, apply指定this指向xiaoming
```





------

## call

与`apply`类似，区别在于

1. `fucntion.apply()` 把传递给function的参数打包在一个`Array`中
2. `call()`把参数按顺序传入

```javascript
Math.max.apply(null, [3, 4, 5]);
Math.max.call(null, 3, 4, 5);
```