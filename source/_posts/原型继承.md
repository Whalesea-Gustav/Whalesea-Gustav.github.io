---
title: 原型继承
date: 2018-09-22 23:42:39
tags: [JavaScript, Font-end]
categories: 网络编程
---
---
# 继承
当谈到继承时，JavaScript 只有一种结构：**对象**。每个实例对象（object ）都有一个私有属性 - ** __proto__** 指向它的原型对象（prototype）。该原型对象也有一个自己的原型对象 ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节

`Student`构造函数
```javascript
function Student(props) {
    this.name = props.name || 'Unamed';
}
Student.prototype.hello = function () {
    alert('Hello, ' + this.name + '!');
};
```


---
# 扩展原型链
现在想基于`Student`扩展出`PrimaryStudent`, 可以先定义出`PrimaryStudent`
```javascript
function PrimaryStudent(props) {
    Student.call(this, props);
    this.grade = props.grade || 1;
}
```
但是调用了`Student`构造函数，并不等于继承了`Student`
`PrimaryStudent`所创建的对象的原型链是
***new PrimaryStudent() ----> PrimaryStudent.prototype ----> Object.prototype ----> null***
事实上，基于`Student`拓展`PrimaryStudent`是想创建如下的原型链
***new PrimaryStudent() ----> PrimaryStudent.prototype ----> Student.prototype ----> Obeject.prototy[e ----> null***

借助一个中间对象来实现正确的原型链，这个中间对象的原型要指向`Student.prototype`。这个中间对象可以**使用空函数`F`**实现

```javascript
function PrimaryStudent(props) {
    Student.call(this, props);
    this grade = props.grade || 1;
}
function F () {
}
// F的原型指向Student的原型
F.prototype = Student.prototype;

//把PrimaryStudent的原型指向一个F对象，那么PrimaryStudent的原型就指向了Student的原型
PrimaryStudent.prototype = new F();
//把`PrimaryStudent`原型的`constructor`修复成`PrimaryStudent`
PrimaryStudent.prototype.constructor = Primary;

//此时可以在PrimaryStudent的原型(也就是new F())上定义新的方法
PrimaryStudent.prototype.getGrade = fucntion () {
    return this.grade;
};
var xiaoming = new PrimaryStudent( {
    name : '小明',
    grade : 2
});
xiaoming.name;              //小明
xiaoming.grade;              // 2
xiaoming.__proto__ === PrimaryStudent.prototype;      // true
xiaoming.__proto__.__proto__ ==Student.prototype;     // true
xiaoming instanceOf PrimaryStudent；                          // true
xiaoming instanceOf Student;                                          // true
```

下图是新的原型链的结构
![relationship](https://cdn.liaoxuefeng.com/cdn/files/attachments/001439872160923ca15925ec79f4692a98404ddb2ed5503000/l)

`new F()` 只是用来连接，并没有改变原有的`Student`定义的原链



---
# 用`inherits`封装
```javascript
function inherist(Child, Parent) {
    var F = function () { };
    F.prototype = Parent.prototype;
    Child.ptototype = new F();
    Child.prototype.constructor = Child;
}
```


---
# PrimaryStudent.prototype = new Student()
不建议直接使用`PrimaryStudent.prototype = new Student()`
先修改下Student的代码
```javascript
    function Student(props) {
        this.name = props.name ? props.name : 'Unnamed';
        this.height = 170
    }
```
如果正常继承，`PrimaryStudent.prototype`里面不能存在`Student`实例中才能存在的`height`和`name`。
如果使用了`PrimaryStudent.prototype = new Student()`，就会发现`PrimaryStudent.prototype`里面存在这两个属性。
如果使用的架桥函数`F`，则`PrimaryStudent.prototype`中只有`Student {constructor: ƒ, getGrade: ƒ}`两个方法。



---
# Object.creat()

不用架桥函数的办法
```javascript
PrimaryStudent.prototype = Object.create(Student.prototype)
```
上面的代码和使用架桥函数的结果一样。

`Object.create`和架桥函数的办法，和使用 `new Student()`的区别在于
使用`Object.create`和架桥函数的时候，只会将`PrimaryStudent.prototype`中的`__proto__`指向`Student`这个函数的**原型对象** `Student.prototype`
而使用`new Student()`的时候，`PrimaryStudent.prototype`指向的是`Student`这个函数对象的**一个实例s**，`Student`函数对象在实例化的时候，会完全拷贝一份`Student.prototype`，也会增加`Student`中的属性，比如`name`



---
# 总结
1.  定义新的构造函数，利用`.call(this, otherParameter)`调用希望继承的构造函数，并绑定`this`
2. 借助空函数`F()`实现原型继承，最好通过封装`inherits`
3. 在新的构造函数原型上就可以定义新的方法

